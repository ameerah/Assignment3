QUESTIONS: my answers

1. The problem size for this assignment is not variable. This means our expected number of hash table entries is a certainty. Considering that it is incredibly small and cannot grow, the time taken to insert or retrieve will be at most O(N) with the linear probing technique I used as opposed to ever so marginally shorter time taken for quadratic probing which uses O(log(N)) - where N is the size of the hash table. In this case, the size is 13 which means that the difference between linear and quadratic probing is so negligible that it is not worth using quadratic probing which is more complicated to implement. 

Additionally, quadratic probing is supposed to reduce the problem of clustering. We can agree that it is inefficient on memory to have a large array for the hash table when only a few elements will be occupying that space but the array would leave much more reserved for other items. So we construct a small array. In this small array, clustering does not become a problem because search time (by traversal through elements of the hash table) is limited and not noticeable in real time. 

With this small array, quadratric probing becomes inefficient as very often it probes to an occupied space if the table is small and full as it wraps around and lands on numbers very close to each. It becames as (in)efficient as linear probing.

The chaining algorithm is not very relevant here as there aren't many collisions with such a small sample. This means every entry in the table stores a link or pointer to a chained entry which does not end up being used; this is inefficient on memory for this problem set. Lastly, it does not save time because of the lack of collisions: the best case of linear probing (where the element is immediately found) almost always executes which is roughly equivalent to the run time for traversal through the chain.

The concession of this inefficiency is made for a larger problem size that is variable; that rehashing would need to be done as would chaining (for a medium sample size for some collisions but not many) and quadratic (for large sample sizes).

2. If you could implement this hybrid in such a way that it follows the same order of algorithm choice each time and insure that an element could be retrieved in the exact same way then it should be a good algorithm. It would improve on the O(N) time of linear probing and the combination of linear and quadratic would result in the same spots being landed on for the same key. This would reduce time taken for insertion and searching. This would reduce clustering of linear probing. It could also prevent the table from creating really long chains at one index. By taking a combination of all three, it effectively addresses the problems posed by all three. However, there may be a loss in efficiency overall as, for the worst case scenario, searching would take longer than O(log(N)) because of the linear search incorporation and chaining. 

3. 4 collisions; linear search meant that it landed at an index was occupied and so were the three after that. It fit into the slot after that.

4. Technically since the table contains 7 elements of 13 (which is greater than 50% which is usually the load factor as at this point there is a greater chance of collision than easy entry with no collision), I should have rehashed. However, for this problem size that isn't variable, the inefficiency incurred from being more likely to hash to an index that already contains an element is negligible because the search, retrieval and insertion time would not be too long. 

If I were to rehash (using the array implementation of a hash table that I used), I would need to create an entirely new array of the next prime number greater than 13. I would then need to traverse through each element in the old array, use a new hash function to find this element's new index and then use one of the three previiously mentioned algorithms for insertion. I imagine it would not make a difference on retrieval time with a table this small because there weren't many collisions
